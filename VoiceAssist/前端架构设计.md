为了配合你的 Python 后端，我为你设计了一个基于 **Web Components** 的前端组件。它采用了响应式设计，并特别强化了针对 3-4 秒等待过程中的 **UX 反馈**（波形动画和状态提示）。

### 1. 前端架构设计

* **技术栈**: 原生 JS (ES6), Tailwind CSS, Web MediaRecorder API。
* **组件名**: `<thai-voice-helper>`。
* **核心逻辑**: 捕获音频 -> 转换为 `FormData` -> 异步提交后端 -> 渲染结果。

---

### 2. 单文件原型 (`index.html`)

你可以直接运行此文件。请确保你的 Python 后端已启动在 `localhost:8000`。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>泰语语音输入助手 - TVHI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 录音波形动画 */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        .recording-active .ring {
            animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }
    </style>
</head>
<body class="bg-slate-100 min-h-screen p-4 md:p-8 flex flex-col items-center">

    <div class="max-w-md w-full">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-extrabold text-slate-800">TVHI Helper</h1>
            <p class="text-slate-500 mt-2">解决键盘输入难题，口音不准也能识别</p>
        </header>

        <thai-voice-helper id="main-helper"></thai-voice-helper>
        
        <footer class="mt-12 text-center text-xs text-slate-400">
            Powered by Gemini 2.5 Flash & PyThaiNLP
        </footer>
    </div>

    <template id="tvh-template">
        <div class="bg-white rounded-3xl shadow-xl p-6 border border-slate-200">
            <div class="mb-6">
                <label class="text-xs font-bold text-slate-400 uppercase tracking-wider">当前场景</label>
                <select id="scene-select" class="w-full mt-1 bg-slate-50 border-none rounded-xl p-3 text-slate-700 outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="general">通用对话 (General)</option>
                    <option value="travel">旅游/交通 (Travel)</option>
                    <option value="restaurant">餐厅/点餐 (Food)</option>
                </select>
            </div>

            <div class="flex flex-col items-center py-8">
                <div id="record-container" class="relative">
                    <div class="ring absolute inset-0 rounded-full bg-blue-400"></div>
                    <button id="record-btn" class="relative z-10 w-20 h-20 bg-blue-600 hover:bg-blue-700 text-white rounded-full flex items-center justify-center transition-all shadow-lg active:scale-95">
                        <svg id="mic-icon" class="w-10 h-10" fill="currentColor" viewBox="0 0 20 20"><path d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 005.93 6.93V17H7a1 1 0 100 2h6a1 1 0 100-2h-2v-2.07z"></path></svg>
                    </button>
                </div>
                <p id="status-text" class="mt-6 text-sm font-medium text-slate-600 italic">点击开始说话</p>
            </div>

            <div id="result-card" class="hidden animate-in fade-in slide-in-from-bottom-4 duration-500">
                <div class="bg-slate-50 rounded-2xl p-4 border border-slate-100 relative group">
                    <label class="text-[10px] font-bold text-blue-500 uppercase">识别结果</label>
                    <div id="thai-output" class="text-2xl font-semibold text-slate-800 my-2 leading-relaxed"></div>
                    <div id="phonetic-hint" class="text-sm text-slate-400 font-mono"></div>
                    
                    <button id="copy-btn" class="absolute top-4 right-4 text-slate-300 hover:text-blue-500 transition-colors">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                    </button>
                </div>
            </div>
        </div>
    </template>

    <script>
        class ThaiVoiceHelper extends HTMLElement {
            constructor() {
                super();
                this.isRecording = false;
                this.mediaRecorder = null;
                this.chunks = [];
                this.attachShadow({ mode: 'open' });
            }

            connectedCallback() {
                const template = document.getElementById('tvh-template');
                this.shadowRoot.appendChild(template.content.cloneNode(true));
                this.init();
            }

            init() {
                this.btn = this.shadowRoot.getElementById('record-btn');
                this.container = this.shadowRoot.getElementById('record-container');
                this.status = this.shadowRoot.getElementById('status-text');
                this.resultCard = this.shadowRoot.getElementById('result-card');
                this.copyBtn = this.shadowRoot.getElementById('copy-btn');

                this.btn.onclick = () => this.toggleRecording();
                this.copyBtn.onclick = () => this.copyToClipboard();
            }

            async toggleRecording() {
                if (this.isRecording) {
                    this.stop();
                } else {
                    await this.start();
                }
            }

            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.mediaRecorder = new MediaRecorder(stream);
                    this.chunks = [];

                    this.mediaRecorder.ondataavailable = (e) => this.chunks.push(e.data);
                    this.mediaRecorder.onstop = () => this.sendToBackend();

                    this.mediaRecorder.start();
                    this.isRecording = true;
                    this.updateUI(true);
                } catch (err) {
                    alert('请允许麦克风访问权限');
                }
            }

            stop() {
                this.mediaRecorder.stop();
                this.isRecording = false;
                this.updateUI(false);
            }

            updateUI(recording) {
                this.container.classList.toggle('recording-active', recording);
                this.btn.classList.toggle('bg-red-500', recording);
                this.status.innerText = recording ? '正在倾听...' : '正在思考...';
                if (!recording) this.btn.disabled = true;
            }

            async sendToBackend() {
                const blob = new Blob(this.chunks, { type: 'audio/webm' });
                const scene = this.shadowRoot.getElementById('scene-select').value;
                const formData = new FormData();
                formData.append('file', blob);
                formData.append('scene', scene);

                try {
                    // 请确保此处 URL 与你的 Python 后端一致
                    const response = await fetch('http://localhost:8000/api/v1/helper/transcribe', {
                        method: 'POST',
                        body: formData
                    });
                    const data = await response.json();

                    if (data.status === 'success') {
                        this.showResult(data.result, data.phonetic_hint);
                    } else {
                        throw new Error(data.message);
                    }
                } catch (err) {
                    this.status.innerText = '出错了: ' + err.message;
                } finally {
                    this.btn.disabled = false;
                }
            }

            showResult(thai, phonetic) {
                this.resultCard.classList.remove('hidden');
                this.shadowRoot.getElementById('thai-output').innerText = thai;
                this.shadowRoot.getElementById('phonetic-hint').innerText = phonetic;
                this.status.innerText = '识别成功';
            }

            copyToClipboard() {
                const text = this.shadowRoot.getElementById('thai-output').innerText;
                navigator.clipboard.writeText(text);
                alert('已复制到剪贴板');
            }
        }

        customElements.define('thai-voice-helper', ThaiVoiceHelper);
    </script>
</body>
</html>

```

---

### 3. 该设计的关键 UX 特色

1. **波形反馈（Pulsing Ring）**:
在录音时，按钮周围会有一个半透明的扩散圆圈。这不仅是视觉装饰，更重要的是它给用户一种“系统正在听我说话”的即时反馈。
2. **“思考中”状态**:
正如我们之前的逻辑推断，。当录音结束时，按钮会变灰色且文字变为“正在思考...”，这能有效管理用户对等待时间的心理预期，减少因 API 响应延迟导致的焦虑。
3. **结果分层显示**:
* **大字体泰语**: 方便直接阅读和复制。
* **Phonetic Hint (词块显示)**: 利用 PyThaiNLP 返回的分词结果。如果用户口语不好，他们可以通过词块结构确认 Gemini 是否补全了正确的助词（如 `ครับ/ค่ะ`）。


4. **复制按钮**:
针对“键盘输入困难”的痛点，用户最直接的操作就是“说 -> 拿走文本 -> 粘贴到聊天窗口”，一键复制是刚需。

---

### 4. 调试建议

1. **HTTPS 问题**: 在 Chrome 中，`getUserMedia` 必须在 `localhost` 或 `https` 环境下才能工作。
2. **CORS 问题**: 已经在 Python FastAPI 代码中添加了 `CORSMiddleware`，确保两端端口一致即可（默认前端 file 协议访问后端可能会报错，建议用 `python -m http.server` 启动前端或通过 VS Code Live Server 运行）。

**你觉得这个界面的交互感如何？是否需要我增加一个“多选候选词”的功能，以便在 Gemini 给出多个备选方案时供用户挑选？**